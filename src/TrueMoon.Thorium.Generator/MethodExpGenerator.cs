// using System.Collections.Immutable;
// using System.Text;
// using Microsoft.CodeAnalysis;
// using Microsoft.CodeAnalysis.CSharp;
// using Microsoft.CodeAnalysis.CSharp.Syntax;
// using CSharpExtensions = Microsoft.CodeAnalysis.CSharp.CSharpExtensions;
//
// namespace TrueMoon.Thorium.Generator;
//
// [Generator(LanguageNames.CSharp)]
// public class MethodExpGenerator : IIncrementalGenerator
// {
//     private const string NamespacePart = "TrueMoon.Generated";
//
//     public void Initialize(IncrementalGeneratorInitializationContext context)
//     {
//         //context.RegisterPostInitializationOutput(context => context.AddSource($"{AttributeName}.g.cs", "namespace " + NamespacePart + "; [AttributeUsage(AttributeTargets.Class)]public class " + AttributeName + " : Attribute { public " + AttributeName + "() {} }"));
//
//         var data = context.SyntaxProvider
//             .CreateSyntaxProvider(CheckInterfaces, GetTypeOrNull)
//             .Where(type => type is not null)
//             .Collect();
//
//         var r = context.CompilationProvider.Combine(data);
//
//         context.RegisterSourceOutput(r, static (sourceProductionContext, d) => Generate1(d.Left, d.Right, sourceProductionContext));
//     }
//
//     private static void Generate1(Compilation compilation, ImmutableArray<TypeSyntax?> interfaces, SourceProductionContext sourceProductionContext)
//     {
//         if (interfaces.IsDefaultOrEmpty)
//         {
//             // nothing to do yet
//             return;
//         }
//
//         var typesList = new List<ITypeSymbol>();
//         
//         var values = interfaces.Distinct();
//         
//         
//         var list = new List<(INamedTypeSymbol interfaceSymbol, List<ISymbol> l)>();
//         foreach (var syntax in values)
//         {
//             SemanticModel semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);
//             var typeInfo = semanticModel.GetTypeInfo(syntax);
//             var typeSymbol = typeInfo.Type;
//             //var classSymbol1 = semanticModel.GetDeclaredSymbol(syntax);
//         
//             if (typeSymbol is not INamedTypeSymbol interfaceSymbol)
//             {
//                 continue;
//             }
//         
//             var l = interfaceSymbol.GetMembers().ToList();
//         
//             list.Add((interfaceSymbol, l));
//         }
//         
//         // var n = compilation.AssemblyName.Replace(".", string.Empty).Trim();
//         // var a = compilation.Assembly.Name;
//         //
//         // var sb = new StringBuilder();
//         // sb.AppendLine("// auto-generated by TrueMoon.Thorium.Generator");
//         // sb.AppendLine("using TrueMoon.Thorium;");
//         // sb.AppendLine();
//         // sb.AppendLine($"namespace {NamespacePart};");
//         // sb.AppendLine();
//         //
//         // foreach (var (type, members) in list)
//         // {
//         //     var name = type?.Name;
//         //     var fullname = type?.ToDisplayString();
//         //
//         //     var implementationClassName = (name.StartsWith("I") ? name.Substring(1) : name) +"GeneratedImplementation";
//         //
//         //     sb.AppendLine($"// {fullname},  {name}");
//         //     sb.AppendLine($"public sealed class {implementationClassName} : {fullname}");
//         //     sb.AppendLine("{");
//         //     sb.AppendLine("    private readonly ISignalInvoker _invoker;");
//         //     sb.AppendLine($"    public {implementationClassName}(ISignalInvoker invoker)");
//         //     sb.AppendLine("    {");
//         //     sb.AppendLine("        _invoker = invoker;");
//         //     sb.AppendLine("    }");
//         //     
//         //     foreach (var member in members)
//         //     {
//         //         if (member is IMethodSymbol methodSymbol)
//         //         {
//         //             var parameters = methodSymbol.Parameters;
//         //             if (parameters.Any())
//         //             {
//         //                 var str = "";
//         //                 foreach (var symbol in parameters)
//         //                 {
//         //                     if (symbol.Type.TypeKind is TypeKind.Class or TypeKind.Struct)
//         //                     {
//         //                         GenerateSerializationExtensions(typesList,sourceProductionContext, symbol.Type);
//         //                     }
//         //
//         //                     str += $"{symbol.Type} {symbol.MetadataName}{(symbol.IsOptional ? " = default" : string.Empty)}, ";
//         //                 }
//         //         
//         //                 str = str.TrimEnd();
//         //                 str = str.TrimEnd(',');
//         //                 sb.AppendLine($"    public {methodSymbol.ReturnType} {member.Name}({str})");
//         //             }
//         //             else
//         //             {
//         //                 sb.AppendLine($"    public {methodSymbol.ReturnType} {member.Name}()");
//         //             }
//         //             sb.AppendLine("    {");
//         //             sb.AppendLine("        return default;");
//         //             sb.AppendLine("    }");
//         //             sb.AppendLine();
//         //         }
//         //     }
//         //     
//         //     sb.AppendLine("}");
//         // }
//         //
//         // var source = sb.ToString();
//         // sourceProductionContext.AddSource($"{n}Services.g.cs", source);
//     }
//
//     private static bool CheckInterfaces(
//         SyntaxNode syntaxNode,
//         CancellationToken cancellationToken)
//     {
//         var kind = syntaxNode.Kind();
//         if (syntaxNode.IsKind(SyntaxKind.GenericName) 
//             && syntaxNode is GenericNameSyntax v
//             && v.Identifier.Text.Contains("ExecContext"))
//         {
//             return true;
//         }
//         return false;
//     }
//
//
//     private static TypeSyntax? GetTypeOrNull(
//         GeneratorSyntaxContext context,
//         CancellationToken cancellationToken)
//     {
//         if (context.Node is GenericNameSyntax i)
//         {
//             if (i.TypeArgumentList.Arguments.Any())
//             {
//                 var node = i.TypeArgumentList.Arguments[0];
//                 return node;
//             }
//
//             //return i;
//         }
//
//         return null;
//     }
// }