using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using TrueMoon.Thorium.Generator.Extensions;
using TrueMoon.Thorium.Generator.Utils;

namespace TrueMoon.Thorium.Generator;

[Generator(LanguageNames.CSharp)]
public class ServicesGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var data = context.SyntaxProvider
            .CreateSyntaxProvider(CheckInterfaces, GetTypeOrNull)
            .Where(type => type is not null)
            .Collect();

        var r = context.CompilationProvider.Combine(data);

        context.RegisterSourceOutput(r, static (sourceProductionContext, d) => Generate1(d.Left, d.Right, sourceProductionContext));
    }

    private static void Generate1(Compilation compilation, ImmutableArray<TypeSyntax?> interfaces, SourceProductionContext sourceProductionContext)
    {
        if (interfaces.IsDefaultOrEmpty)
        {
            return;
        }

        try
        {
            //var n = compilation.AssemblyName.Replace(".", string.Empty).Trim();
            var assembly = compilation.Assembly.Name;
            
            var ctx = new GenerationContext(sourceProductionContext, assembly);
        
            var values = interfaces.Distinct();
        

            var list = new List<(INamedTypeSymbol interfaceSymbol, List<ISymbol> l)>();
            foreach (var syntax in values)
            {
                SemanticModel semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);
                var typeInfo = semanticModel.GetTypeInfo(syntax);
                var typeSymbol = typeInfo.Type;

                if (typeSymbol is not INamedTypeSymbol interfaceSymbol)
                {
                    continue;
                }
        
                if (list.Any(t=> SymbolEqualityComparer.Default.Equals(t.interfaceSymbol, interfaceSymbol)))
                {
                    continue;
                }
                
                var l = interfaceSymbol.GetMembers().ToList();
                
                list.Add((interfaceSymbol, l));
            }

            var services = new List<(string, string)>();
            var handlers = new List<(string, string)>();
            
            foreach (var (type, members) in list)
            {
                var implementation = GenerateService(ctx, type, members);
                services.Add(($"{type}", $"{ctx.NamespacePrefix}.{implementation}"));

                var handler = GenerateHandler(ctx, type, members);
                handlers.Add(($"{type}", $"{ctx.NamespacePrefix}.{handler}"));
            }
        
            var sb = new StringBuilder();
            sb.AppendLine("// auto-generated by TrueMoon.Thorium.Generator");
            sb.AppendLine("using TrueMoon.Thorium;");
            sb.AppendLine("using TrueMoon.Thorium.IO;");
            sb.AppendLine("using System.Runtime.CompilerServices;");
            sb.AppendLine();
            sb.AppendLine($"namespace {ctx.NamespacePrefix};");
            sb.AppendLine();
        
            sb.AppendLine("public static class ModuleInitializer");
            sb.AppendLine("{");
            sb.AppendLine("    [ModuleInitializer]");
            sb.AppendLine("    public static void Init()");
            sb.AppendLine("    {");
            foreach (var service in services)
            {
                sb.AppendLine($"        InvocationServiceStorage.Shared.Register<global::{service.Item1},global::{service.Item2}>();");
            }
            foreach (var handler in handlers)
            {
                sb.AppendLine($"        InvocationServiceStorage.Shared.RegisterHandler<IInvocationServerHandler<global::{handler.Item1}>,global::{handler.Item2}>();");
            }
            sb.AppendLine("    }");
            sb.AppendLine("}");

            var source = sb.ToString();
            sourceProductionContext.AddSource("InvocationServiceInitializer.g.cs", source);
        }
        catch (Exception e)
        {
            throw new InvalidOperationException($"Exception - {e.GetType()}: {e.Message}, StackTrace: {e.StackTrace}", e);
        }
    }

    private static string GenerateService(GenerationContext context, 
        INamedTypeSymbol type,
        IReadOnlyList<ISymbol> members)
    {
        var handle = context.CreateSourceHandle(type);
        handle.BeginServiceGeneratedImplementation();

        byte methodIndex = 0;
        foreach (var member in members)
        {
            if (member is not IMethodSymbol methodSymbol) continue;
            handle.GenerateMethod(methodSymbol, methodIndex);
            methodIndex++;
        }

        handle.Complete();

        return handle.ImplementationClassName;
    }
    
    private static string GenerateHandler(GenerationContext context, 
        INamedTypeSymbol type,
        IReadOnlyList<ISymbol> members)
    {
        var handle = context.CreateSourceHandle(type,"InvocationServerHandler");
        handle.BeginServiceHandler();
        
        var methodIndex = 0;
        foreach (var member in members)
        {
            if (member is IMethodSymbol methodSymbol)
            {   
                var (returnType, _, isTask, returnTypeSymbol) = methodSymbol.GetReturnDetails();

                handle.AppendLine($"            case {methodIndex}:");
                handle.AppendLine("            {");
                if (returnType is not null)
                {
                    handle.AppendLine($"                {GenerationUtils.GetTypeString(returnTypeSymbol)} result = default;");
                }
                handle.AppendLine("                try");
                handle.AppendLine("                {");
                string parametersStr = string.Empty;
                if (methodSymbol.Parameters.Any())
                {
                    handle.AppendLine("                    var offset = 0;");
                    foreach (var parameterSymbol in methodSymbol.Parameters)
                    {
                        if (WellKnownTypes.IsCancellationToken(parameterSymbol.Type))
                        {
                            parametersStr += "cancellationToken, ";
                        }
                        else
                        {
                            var metadataName = parameterSymbol.MetadataName;
                            var parameterTypeString = GenerationUtils.GetTypeString(parameterSymbol.Type);
                            handle.AppendLine($"                    {parameterTypeString} {metadataName} = default;");

                            switch (parameterSymbol.Type)
                            {
                                case IArrayTypeSymbol ar:
                                {
                                    var arrayItemType = ar.ElementType;
                                    var r = handle.GenerateDeserializationForItemsBase(arrayItemType, metadataName, spanSource:"readHandle.Span");
                                    handle.AppendLine($"            {metadataName} = {r};");
                                    break;
                                }
                                case INamedTypeSymbol { IsTupleType:true, TupleElements.IsEmpty:false } tupleSymbol:
                                {
                                    var r = handle.GenerateDeserializationForTuple(tupleSymbol, metadataName, spanSource:"readHandle.Span");
                                    handle.AppendLine($"            {metadataName} = {r};");
                                    break;
                                }
                                case INamedTypeSymbol
                                {
                                    TypeKind: TypeKind.Class or TypeKind.Interface or TypeKind.Error, IsGenericType: true, Name: "List" or "IReadOnlyList"
                                } p:
                                {
                                    var listItemType = p.TypeArguments.First();
                                    var r = handle.GenerateDeserializationForItemsBase(listItemType, metadataName, true, spanSource:"readHandle.Span");
                                    handle.AppendLine($"            {metadataName} = {r};");
                                    break;
                                }
                                case INamedTypeSymbol
                                {
                                    TypeKind: TypeKind.Class or TypeKind.Interface or TypeKind.Error, IsGenericType: true,
                                    Name: "Dictionary" or "IReadOnlyDictionary"
                                } p:
                                {
                                    var keyType = p.TypeArguments[0];
                                    var valueType = p.TypeArguments[1];
                                    var r = handle.GenerateDeserializationForDictionaryBase(keyType, valueType, metadataName, spanSource:"readHandle.Span");
                                    handle.AppendLine($"            {metadataName} = {r};");
                                    break;
                                }
                                case { TypeKind: TypeKind.Class or TypeKind.Struct }
                                    when WellKnownTypes.NotContains(parameterSymbol.Type):
                                {
                                    handle.AppendLine($"                    {metadataName} = {metadataName}.Deserialize(readHandle.Span, ref offset);");
                                    break;
                                }
                                default:
                                {
                                    var b = parameterSymbol.Type switch
                                    {
                                        {} when parameterSymbol.Type.Name.Equals("string", StringComparison.InvariantCultureIgnoreCase) => "String",
                                        {} when parameterSymbol.Type.Name.Contains("Memory") => "Bytes",
                                        INamedTypeSymbol { NullableAnnotation: NullableAnnotation.Annotated } => $"<{$"{parameterTypeString}".TrimEnd('?')}>",
                                        _ => $"<{parameterTypeString}>"
                                    };
                    
                                    if (parameterSymbol.Type is INamedTypeSymbol { NullableAnnotation: NullableAnnotation.Annotated })
                                    {
                                        handle.AppendLine("            if (SerializationUtils.ReadInstanceState(readHandle.Span[offset..], ref offset))");
                                        handle.AppendLine("            {");
                                        handle.AppendLine(parameterSymbol.Type.TypeKind == TypeKind.Enum
                                            ? $"                {metadataName} = ({parameterTypeString})SerializationUtils.Read<int>(readHandle.Span[offset..], ref offset);"
                                            : $"                {metadataName} = SerializationUtils.Read{b}(readHandle.Span[offset..], ref offset);");
                                        handle.AppendLine("            }");
                                    }
                                    else
                                    {
                                        handle.AppendLine(parameterSymbol.Type.TypeKind == TypeKind.Enum
                                            ? $"            {metadataName} = ({parameterTypeString})SerializationUtils.Read<int>(readHandle.Span[offset..], ref offset);"
                                            : $"            {metadataName} = SerializationUtils.Read{b}(readHandle.Span[offset..], ref offset);");
                                    }
                                    break;
                                }
                            }

                            parametersStr += $"{metadataName}, ";
                        }
                    }
                }
                parametersStr = parametersStr.TrimEnd(' ', ',');

                handle.AppendLine(returnType is not null
                    ? $"                    result = {(isTask ? "await " : string.Empty)}_service.{member.MetadataName}({parametersStr});"
                    : $"                    {(isTask ? "await " : string.Empty)}_service.{member.MetadataName}({parametersStr});");

                handle.AppendLine("                }");
                handle.AppendLine("                catch (Exception e)");
                handle.AppendLine("                {");
                handle.AppendLine("                    _eventsSource.Exception(e);");
                handle.AppendLine("                    return (false,e);");
                handle.AppendLine("                }");

                if (returnType is not null)
                {
                    var isAnnotated = returnTypeSymbol.NullableAnnotation == NullableAnnotation.Annotated;
            
                    if (returnTypeSymbol is INamedTypeSymbol {MetadataName:"Nullable`1", TypeArguments.Length:1} tp && isAnnotated)
                    {
                        returnTypeSymbol = tp.TypeArguments[0];
                    }
                    
                    switch (returnTypeSymbol)
                    {
                        case IArrayTypeSymbol ar:
                        {
                            var arrayItemType = ar.ElementType;
                            handle.GenerateSerializationForItems(arrayItemType, "result", instanceName:"");
                            break;
                        }
                        case INamedTypeSymbol { IsTupleType:true, TupleElements.IsEmpty:false } tupleSymbol:
                        {
                            handle.GenerateSerializationForTuple(tupleSymbol, "result", instanceName:"");
                            break;
                        }
                        case INamedTypeSymbol
                        {
                            TypeKind: TypeKind.Class or TypeKind.Interface or TypeKind.Error, IsGenericType: true, Name: "List" or "IReadOnlyList"
                        } p:
                        {
                            var listItemType = p.TypeArguments.First();
                            handle.GenerateSerializationForItems(listItemType, "result", isCount:true, instanceName:"");
                            break;
                        }
                        case INamedTypeSymbol
                        {
                            TypeKind: TypeKind.Class or TypeKind.Interface or TypeKind.Error, IsGenericType: true,
                            Name: "Dictionary" or "IReadOnlyDictionary"
                        } p:
                        {
                            var keyType = p.TypeArguments[0];
                            var valueType = p.TypeArguments[1];
                            handle.GenerateSerializationForDictionary(keyType, valueType, "result", instanceName:"");
                            break;
                        }
                        case {TypeKind:TypeKind.Class or TypeKind.Struct} 
                       when WellKnownTypes.NotContains(returnType.TrimEnd('?')):
                            handle.AppendLine("                result.Serialize(bufferWriter);");
                            break;
                        default:
                        {
                            var b = returnTypeSymbol switch
                            {
                                {} when returnTypeSymbol.Name.Equals("string", StringComparison.InvariantCultureIgnoreCase) => "String",
                                {} when returnTypeSymbol.Name.Contains("Memory") => "Bytes",
                                _ => ""
                            };
                
                            if (isAnnotated)
                            {
                                handle.AppendLine($"            if (result != null)");
                                handle.AppendLine("            {");
                                handle.AppendLine("                SerializationUtils.WriteInstanceState(true, bufferWriter);");
                                handle.AppendLine(returnTypeSymbol.TypeKind == TypeKind.Enum
                                    ? $"               SerializationUtils.Write<int>((int)result.Value, bufferWriter);"
                                    : $"               SerializationUtils.Write{b}(result.Value, bufferWriter);");
                                handle.AppendLine("            }");
                                handle.AppendLine("            else");
                                handle.AppendLine("            {");
                                handle.AppendLine("                SerializationUtils.WriteInstanceState(false, bufferWriter);");
                                handle.AppendLine("            }");
                            }
                            else
                            {
                                handle.AppendLine(returnTypeSymbol.TypeKind == TypeKind.Enum
                                    ? $"           SerializationUtils.Write<int>((int)result, bufferWriter);"
                                    : $"           SerializationUtils.Write{b}(result, bufferWriter);");
                            }

                            break;
                        }
                    }
                }

                handle.AppendLine("            }");
                handle.AppendLine("            break;");
                methodIndex++;
            }
        }
        handle.AppendLine("        }");

        handle.AppendLine("        return (true, null);");
        handle.AppendLine("    }");
        
        handle.Complete();
        
        return handle.ImplementationClassName;
    }
    
    
    private static bool CheckInterfaces(
        SyntaxNode syntaxNode,
        CancellationToken cancellationToken) =>
        syntaxNode.IsKind(SyntaxKind.GenericName) 
        && syntaxNode is GenericNameSyntax v
        && (v.Identifier.Text.Contains("UseInvocationService") || v.Identifier.Text.Contains("ListenInvocationService"));


    private static TypeSyntax? GetTypeOrNull(
        GeneratorSyntaxContext context,
        CancellationToken cancellationToken)
    {
        if (context.Node is GenericNameSyntax i && i.TypeArgumentList.Arguments.Any())
        {
            var node = i.TypeArgumentList.Arguments[0];
            return node;
        }

        return null;
    }
}