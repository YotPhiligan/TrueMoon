using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace TrueMoon.Thorium.Generator;

[Generator(LanguageNames.CSharp)]
public class ServicesGenerator : IIncrementalGenerator
{
    private const string NamespacePart = "TrueMoon.Generated";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var data = context.SyntaxProvider
            .CreateSyntaxProvider(CheckInterfaces, GetTypeOrNull)
            .Where(type => type is not null)
            .Collect();

        var r = context.CompilationProvider.Combine(data);

        context.RegisterSourceOutput(r, static (sourceProductionContext, d) => Generate1(d.Left, d.Right, sourceProductionContext));
    }

    private static void Generate1(Compilation compilation, ImmutableArray<TypeSyntax?> interfaces, SourceProductionContext sourceProductionContext)
    {
        if (interfaces.IsDefaultOrEmpty)
        {
            return;
        }

        var typesList = new List<ITypeSymbol>();
        
        var values = interfaces.Distinct();
        

        var list = new List<(INamedTypeSymbol interfaceSymbol, List<ISymbol> l)>();
        foreach (var syntax in values)
        {
            SemanticModel semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);
            var typeInfo = semanticModel.GetTypeInfo(syntax);
            var typeSymbol = typeInfo.Type;

            if (typeSymbol is not INamedTypeSymbol interfaceSymbol)
            {
                continue;
            }
        
            var l = interfaceSymbol.GetMembers().ToList();
        
            list.Add((interfaceSymbol, l));
        }
        
        var n = compilation.AssemblyName.Replace(".", string.Empty).Trim();
        var a = compilation.Assembly.Name;

        var services = new List<(string, string)>();
        var handlers = new List<(string, string)>();
        foreach (var (type, members) in list)
        {
            var implementation = GenerateService(sourceProductionContext, type, members, typesList);
            services.Add(($"{type}", $"{NamespacePart}.{implementation}"));

            var handler = GenerateHandler(sourceProductionContext, type, members);
            handlers.Add(($"{type}", $"{NamespacePart}.{handler}"));
        }
        
        var sb = new StringBuilder();
        sb.AppendLine("// auto-generated by TrueMoon.Thorium.Generator");
        sb.AppendLine("using TrueMoon.Thorium;");
        sb.AppendLine("using TrueMoon.Thorium.IO;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine();
        sb.AppendLine($"namespace {NamespacePart};");
        sb.AppendLine();
        
        sb.AppendLine("public static class ModuleInitializer");
        sb.AppendLine("{");
        sb.AppendLine("    [ModuleInitializer]");
        sb.AppendLine("    public static void Init()");
        sb.AppendLine("    {");
        foreach (var service in services)
        {
            sb.AppendLine($"        SignalServiceStorage.Shared.Register<{service.Item1},{service.Item2}>();");
        }
        foreach (var handler in handlers)
        {
            sb.AppendLine($"        SignalServiceStorage.Shared.RegisterHandler<ISignalServerHandler<{handler.Item1}>,{handler.Item2}>();");
        }
        sb.AppendLine("    }");
        sb.AppendLine("}");

        var source = sb.ToString();
        sourceProductionContext.AddSource("SignalServiceInitializer.g.cs", source);
    }

    private static string GenerateService(SourceProductionContext sourceProductionContext, INamedTypeSymbol type,
        List<ISymbol> members, List<ITypeSymbol> typesList)
    {
        var name = type?.Name;
        var fullname = type?.ToDisplayString();

        var implementationClassName = (name.StartsWith("I") ? name.Substring(1) : name) + "GeneratedImplementation";

        var sb = new StringBuilder();
        sb.AppendLine("// auto-generated by TrueMoon.Thorium.Generator");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using TrueMoon.Thorium.IO;");
        sb.AppendLine();
        sb.AppendLine($"namespace {NamespacePart};");
        sb.AppendLine();

        sb.AppendLine($"// {fullname}");
        sb.AppendLine($"public sealed class {implementationClassName} : {fullname}");
        sb.AppendLine("{");
        sb.AppendLine($"    private readonly ISignalClient<{fullname}> _signalClient;");
        sb.AppendLine($"    public {implementationClassName}(ISignalClient<{fullname}> signalClient)");
        sb.AppendLine("    {");
        sb.AppendLine("        _signalClient = signalClient;");
        sb.AppendLine("    }");
        sb.AppendLine();

        byte methodIndex = 0;
        foreach (var member in members)
        {
            if (member is IMethodSymbol methodSymbol)
            {
                GenerateMethod(sourceProductionContext, typesList, methodSymbol, methodIndex, sb);
                methodIndex++;
            }
        }

        sb.AppendLine("}");

        var source = sb.ToString();
        sourceProductionContext.AddSource($"{implementationClassName}.g.cs", source);

        return implementationClassName;
    }
    
    private static string GenerateHandler(SourceProductionContext sourceProductionContext, INamedTypeSymbol type,
        List<ISymbol> members)
    {
        var name = type?.Name;
        var fullname = type?.ToDisplayString();

        var handlerImplementationClassName = (name.StartsWith("I") ? name.Substring(1) : name) + "SignalServerHandler";

        var sb = new StringBuilder();
        sb.AppendLine("// auto-generated by TrueMoon.Thorium.Generator");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Buffers;");
        sb.AppendLine("using TrueMoon.Diagnostics;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using TrueMoon.Thorium.IO;");
        
        sb.AppendLine();
        sb.AppendLine($"namespace {NamespacePart};");
        sb.AppendLine();

        sb.AppendLine($"// {fullname}");
        sb.AppendLine($"public sealed class {handlerImplementationClassName} : ISignalServerHandler<{fullname}>");
        sb.AppendLine("{");
        sb.AppendLine($"    private readonly {fullname} _service;");
        sb.AppendLine($"    private readonly IEventsSource<{handlerImplementationClassName}> _eventsSource;");
        sb.AppendLine($"    public {handlerImplementationClassName}({fullname} service, IEventsSource<{handlerImplementationClassName}> eventsSource)");
        sb.AppendLine("    {");
        sb.AppendLine("        _service = service;");
        sb.AppendLine("        _eventsSource = eventsSource;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public async Task<bool> HandleAsync(byte method, IMemoryReadHandle readHandle, IBufferWriter<byte> bufferWriter, CancellationToken cancellationToken = default)");
        sb.AppendLine("    {");
        sb.AppendLine("        switch (method)");
        sb.AppendLine("        {");
        var methodIndex = 0;
        foreach (var member in members)
        {
            if (member is IMethodSymbol methodSymbol)
            {
                var (returnType, _, isTask) = GetMethodReturnDetails(methodSymbol);

                sb.AppendLine($"            case {methodIndex}:");
                sb.AppendLine("            {");
                if (returnType is not null)
                {
                    sb.AppendLine($"                {returnType} result = default;");
                }
                sb.AppendLine("                try");
                sb.AppendLine("                {");
                string parametersStr = string.Empty;
                if (methodSymbol.Parameters.Any())
                {
                    sb.AppendLine("                    var offset = 0;");
                    foreach (var parameterSymbol in methodSymbol.Parameters)
                    {
                        if (WellKnownTypes.IsCancellationToken(parameterSymbol.Type))
                        {
                            parametersStr += "cancellationToken, ";
                        }
                        else
                        {
                            var metadataName = parameterSymbol.MetadataName;
                            sb.AppendLine($"                    {parameterSymbol.Type} {metadataName} = default;");
                            if (WellKnownTypes.NotContains(parameterSymbol.Type))
                            {
                                sb.AppendLine($"                    {metadataName} = {metadataName}.Deserialize(readHandle.GetData()[offset..], ref offset);");
                            }
                            else
                            {
                                if (parameterSymbol.Type.Name.Equals("string", StringComparison.InvariantCultureIgnoreCase))
                                {
                                    sb.AppendLine($"                    {metadataName} = SerializationUtils.ReadString(readHandle.GetData()[offset..], ref offset);");
                                }
                                else if (parameterSymbol.Type.Name.Contains("Memory"))
                                {
                                    sb.AppendLine($"                    {metadataName} = SerializationUtils.ReadBytes(readHandle.GetData()[offset..], ref offset);");
                                }
                                else 
                                {
                                    sb.AppendLine($"                    {metadataName} = SerializationUtils.Read<{parameterSymbol.Type}>(readHandle.GetData()[offset..], ref offset);");
                                }
                            }
                            parametersStr += $"{metadataName}, ";
                        }
                    }
                }
                parametersStr = parametersStr.TrimEnd(' ', ',');

                sb.AppendLine(returnType is not null
                    ? $"                    result = {(isTask ? "await " : string.Empty)}_service.{member.MetadataName}({parametersStr});"
                    : $"                    {(isTask ? "await " : string.Empty)}_service.{member.MetadataName}({parametersStr});");

                sb.AppendLine("                }");
                sb.AppendLine("                catch (Exception e)");
                sb.AppendLine("                {");
                sb.AppendLine("                    _eventsSource.Exception(e);");
                sb.AppendLine("                    return false;");
                sb.AppendLine("                }");

                if (returnType is not null)
                {
                    if (WellKnownTypes.NotContains(returnType))
                    {
                        sb.AppendLine("                result.Serialize(bufferWriter);");
                    }
                    else
                    {
                        if (returnType.Equals("string", StringComparison.InvariantCultureIgnoreCase))
                        {
                            sb.AppendLine("                SerializationUtils.WriteString(result, bufferWriter);");
                        }
                        else if (returnType.Contains("Memory"))
                        {
                            sb.AppendLine("                SerializationUtils.WriteBytes(result, bufferWriter);");
                        }
                        else 
                        {
                            sb.AppendLine("                SerializationUtils.Write(result, bufferWriter);");
                        }
                    }
                }

                sb.AppendLine("            }");
                sb.AppendLine("            break;");
                methodIndex++;
            }
        }
        sb.AppendLine("        }");

        sb.AppendLine("        return true;");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        var source2 = sb.ToString();
        sourceProductionContext.AddSource($"{handlerImplementationClassName}.g.cs", source2);
        
        return handlerImplementationClassName;
    }
        
    private static (string? type, bool isVoid, bool isTask) GetMethodReturnDetails(IMethodSymbol methodSymbol)
    {
        var isTask = $"{methodSymbol.ReturnType}" == "Task" || methodSymbol.ReturnType.ToDisplayString().Contains("Task");
        var isVoid = $"{methodSymbol.ReturnType}" == "void" || methodSymbol.ReturnType.ToDisplayString().Contains("void");
        
        string? returnType = isVoid 
            ? default 
            : (isTask ? default : $"{methodSymbol.ReturnType}");
        
        if (isTask && methodSymbol.ReturnType is INamedTypeSymbol { IsGenericType: true } v
                   && v.TypeArguments.Any())
        {
            returnType = $"{v.TypeArguments[0]}";
        }

        return (returnType, isVoid, isTask);
    }

    private static void GenerateMethod(SourceProductionContext sourceProductionContext, List<ITypeSymbol> typesList,
        IMethodSymbol methodSymbol, byte methodIndex, StringBuilder sb)
    {
        var parameters = methodSymbol.Parameters;
        var anyParameters = parameters.Any();
        
        var str = "";
        string? cancellationTokenParameter = default;

        if (anyParameters)
        {
            foreach (var symbol in parameters)
            {
                if (symbol.Type.TypeKind is TypeKind.Class or TypeKind.Struct)
                {
                    GenerateSerializationExtensions(typesList, sourceProductionContext, symbol.Type);
                }

                str += $"{symbol.Type} {symbol.MetadataName}{(symbol.IsOptional ? " = default" : string.Empty)}, ";

                if (symbol.Type.Name.Contains("CancellationToken"))
                {
                    cancellationTokenParameter = symbol.MetadataName;
                }
            }
        }

        str = str.TrimEnd();
        str = str.TrimEnd(',');

        var (returnType, isVoid, isTask) = GetMethodReturnDetails(methodSymbol);

        sb.AppendLine($"    public {methodSymbol.ReturnType} {methodSymbol.Name}({str})");
        sb.AppendLine("    {");
        if (isTask)
        {
            sb.AppendLine($"        return _signalClient.InvokeAsync({methodIndex}");
        }
        else
        {
            sb.AppendLine(isVoid
                ? $"        _signalClient.Invoke({methodIndex}"
                : $"        return _signalClient.Invoke({methodIndex}");
        }
        if (parameters.Length == 0 || (parameters.Length == 1 && cancellationTokenParameter != null))
        {
            sb.AppendLine("            , null");
        }
        else
        {
            sb.AppendLine("            , writer =>");
            sb.AppendLine("            {");
            foreach (var parameterSymbol in parameters.Where(parameterSymbol => !WellKnownTypes.IsCancellationToken(parameterSymbol.Type)))
            {
                if (WellKnownTypes.NotContains(parameterSymbol.Type))
                {
                    sb.AppendLine($"                {parameterSymbol.MetadataName}.Serialize(writer);");
                }
                else
                {
                    if (parameterSymbol.Type.Name.Equals("string", StringComparison.InvariantCultureIgnoreCase))
                    {
                        sb.AppendLine($"                SerializationUtils.WriteString({parameterSymbol.MetadataName}, writer);");
                    }
                    else if (parameterSymbol.Type.Name.Contains("Memory"))
                    {
                        sb.AppendLine($"                SerializationUtils.WriteBytes({parameterSymbol.MetadataName}, writer);");
                    }
                    else 
                    {
                        sb.AppendLine($"                SerializationUtils.Write({parameterSymbol.MetadataName}, writer);");
                    }
                }
            }
            sb.AppendLine("            }");
        }

        if (!isVoid && returnType is not null)
        {
            sb.AppendLine("            , handle =>");
            sb.AppendLine("            {");
            sb.AppendLine("                var offset = 0;");
            sb.AppendLine($"                {returnType} result = default;");
            
            if (WellKnownTypes.NotContains(returnType))
            {
                sb.AppendLine("                return result.Deserialize(handle.GetData(), ref offset);");
            }
            else
            {
                if (returnType.Equals("string", StringComparison.InvariantCultureIgnoreCase))
                {
                    sb.AppendLine($"                result = SerializationUtils.ReadString(handle.GetData(), ref offset);");
                }
                else if (returnType.Contains("Memory"))
                {
                    sb.AppendLine($"                result = SerializationUtils.ReadBytes(handle.GetData(), ref offset);");
                }
                else 
                {
                    sb.AppendLine($"                result = SerializationUtils.Read<{returnType}>(handle.GetData(), ref offset);");
                }
                sb.AppendLine("                return result;");
            }
            sb.AppendLine("            }");
        }
        
        sb.AppendLine(cancellationTokenParameter != null
            ? $"            , {cancellationTokenParameter});"
            : "            );");
        sb.AppendLine("    }");

        sb.AppendLine();
    }

    private static void GenerateSerializationExtensions(List<ITypeSymbol> types, SourceProductionContext sourceProductionContext, ITypeSymbol type)
    {
        if (WellKnownTypes.Contains(type))
        {
            return;
        }
        
        if (types.Contains(type))
        {
            return;
        }
        types.Add(type);
        
        var name = type.Name;
        var fullname = type.Name;

        var members = type.GetMembers();

        var sb = new StringBuilder();
        sb.AppendLine("// auto-generated by TrueMoon.Thorium.Generator");
        sb.AppendLine("using System.Buffers;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using TrueMoon.Thorium;");
        sb.AppendLine("using TrueMoon.Thorium.IO;");
        sb.AppendLine();
        sb.AppendLine($"namespace {NamespacePart};");
        sb.AppendLine();
        
        sb.AppendLine($"// {type},  {name}");
        sb.AppendLine($"public static class {name}SerializationExtensions");
        sb.AppendLine("{");

        sb.AppendLine($"    public static void Serialize(this {type}? instance, IBufferWriter<byte> bufferWriter)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (instance != null)"); 
        sb.AppendLine("        {");
        sb.AppendLine("            SerializationUtils.WriteInstanceState(true, bufferWriter);");
        foreach (var member in members)
        {
            switch (member)
            {
                case IPropertySymbol property when property.SetMethod == null || property.DeclaredAccessibility != Accessibility.Public:
                    continue;
                case IPropertySymbol property:
                    ProcessMemberTypeSerialization(sourceProductionContext, sb, property.Name, property.Type, types);
                    break;
                case IFieldSymbol field when field.IsReadOnly || field.IsConst || field.DeclaredAccessibility != Accessibility.Public:
                    continue;
                case IFieldSymbol field:
                    ProcessMemberTypeSerialization(sourceProductionContext, sb, field.Name, field.Type, types);
                    break;
            }
        }
        sb.AppendLine("        }");
        sb.AppendLine("        else");
        sb.AppendLine("        {");
        sb.AppendLine("            SerializationUtils.WriteInstanceState(false, bufferWriter);");
        sb.AppendLine("        }");


        sb.AppendLine("    }");
    
        sb.AppendLine();
        
        sb.AppendLine($"    public static {type} Deserialize(this {type}? instance, ReadOnlySpan<byte> span, ref int offset)");
        sb.AppendLine("    {");
        sb.AppendLine($"        {type}? result = default;");
        sb.AppendLine("        if (SerializationUtils.ReadInstanceState(span[offset..], ref offset))");
        sb.AppendLine("        {");
        sb.AppendLine($"            result = new {type}();");
        foreach (var member in members)
        {
            switch (member)
            {
                case IPropertySymbol property when property.SetMethod == null || property.DeclaredAccessibility != Accessibility.Public:
                    continue;
                case IPropertySymbol property:
                    ProcessMemberTypeDeserialization(sb, property.Name, property.Type);
                    break;
                case IFieldSymbol field when field.IsReadOnly || field.IsConst || field.DeclaredAccessibility != Accessibility.Public:
                    continue;
                case IFieldSymbol field:
                    ProcessMemberTypeDeserialization(sb, field.Name, field.Type);
                    break;
            }
        }
        sb.AppendLine("        };");
        sb.AppendLine("        return result;");

        sb.AppendLine("    }");

        sb.AppendLine("}");

        var source = sb.ToString();
        
        sourceProductionContext.AddSource($"{fullname}SerializationExtensions.g.cs", source);
    }

    private static void ProcessMemberTypeSerialization(SourceProductionContext context, StringBuilder sb, string name, ITypeSymbol typeSymbol, List<ITypeSymbol> types)
    {
        switch (typeSymbol)
        {
            case IArrayTypeSymbol ar:
            {
                var arrayItemType = ar.ElementType;
                GenerateSerializationForItems(types, context, arrayItemType, sb, name);
                break;
            }
            case INamedTypeSymbol { TypeKind: TypeKind.Class or TypeKind.Interface or TypeKind.Error, IsGenericType: true, Name: "List" or "IReadOnlyList" } p:
            {
                var listItemType = p.TypeArguments.First();
                GenerateSerializationForItems(types, context, listItemType, sb, name, true);
                break;
            }
            case { TypeKind: TypeKind.Enum }:
                sb.AppendLine($"            SerializationUtils.Write<int>((int)instance.{name}, bufferWriter);");
                break;
            case { TypeKind: TypeKind.Class or TypeKind.Struct } when WellKnownTypes.NotContains(typeSymbol):
                GenerateSerializationExtensions(types, context, typeSymbol);
                sb.AppendLine($"            instance.{name}.Serialize(bufferWriter);");
                break;
            default:
            {
                if (typeSymbol.Name.Equals("string", StringComparison.InvariantCultureIgnoreCase))
                {
                    sb.AppendLine($"            SerializationUtils.WriteString(instance.{name}, bufferWriter);");
                }
                else if (typeSymbol.Name.Contains("Memory"))
                {
                    sb.AppendLine($"            SerializationUtils.WriteBytes(instance.{name}, bufferWriter);");
                }
                else
                {
                    sb.AppendLine($"            SerializationUtils.Write(instance.{name}, bufferWriter);");
                }

                break;
            }
        }
    }

    private static void ProcessMemberTypeDeserialization(StringBuilder sb, string name, ITypeSymbol typeSymbol)
    {
        switch (typeSymbol)
        {
            case IArrayTypeSymbol ar:
            {
                var arrayItemType = ar.ElementType;
                GenerateDeserializationForItems(arrayItemType, sb, name);
                break;
            }
            case INamedTypeSymbol { TypeKind: TypeKind.Class or TypeKind.Interface or TypeKind.Error, IsGenericType: true, Name: "List" or "IReadOnlyList" } p:
            {
                var listItemType = p.TypeArguments.First();
                GenerateDeserializationForItems(listItemType, sb, name, true);
                break;
            }
            case { TypeKind: TypeKind.Enum }:
                sb.AppendLine($"            result.{name} = ({typeSymbol})SerializationUtils.Read<int>(span[offset..], ref offset);");
                break;
            case { TypeKind: TypeKind.Class or TypeKind.Struct } when WellKnownTypes.NotContains(typeSymbol):
                sb.AppendLine($"            result.{name} = result.{name}.Deserialize(span, ref offset);");
                break;
            default:
            {
                if (typeSymbol.Name.Equals("string", StringComparison.InvariantCultureIgnoreCase))
                {
                    sb.AppendLine($"            result.{name} = SerializationUtils.ReadString(span[offset..], ref offset);");
                }
                else if (typeSymbol.Name.Contains("Memory"))
                {
                    sb.AppendLine($"            result.{name} = SerializationUtils.ReadBytes(span[offset..], ref offset);");
                }
                else
                {
                    sb.AppendLine($"            result.{name} = SerializationUtils.Read<{typeSymbol}>(span[offset..], ref offset);");
                }

                break;
            }
        }
    }
    
    private static void GenerateSerializationForItems(List<ITypeSymbol> types, SourceProductionContext sourceProductionContext,
        ITypeSymbol arrayItemType, StringBuilder sb, string propertyName, bool isCount = false)
    {
        var sizeStr = isCount ? "Count" : "Lenght";
        sb.AppendLine($"            if (instance.{propertyName} != null)");
        sb.AppendLine("            {");
        sb.AppendLine("                SerializationUtils.WriteInstanceState(true, bufferWriter);");
        sb.AppendLine($"                SerializationUtils.WriteElementsCount(instance.{propertyName}.{sizeStr}, bufferWriter);");
        sb.AppendLine($"                for(var i = 0; i < instance.{propertyName}.{sizeStr}; i++)");
        sb.AppendLine("                {");
        sb.AppendLine($"                    var item = instance.{propertyName}[i];");
        if (arrayItemType is { TypeKind: TypeKind.Class or TypeKind.Struct } && WellKnownTypes.NotContains(arrayItemType))
        {
            GenerateSerializationExtensions(types, sourceProductionContext, arrayItemType);
            sb.AppendLine("                    item.Serialize(bufferWriter);");
        }
        else if (arrayItemType.Name.Equals("string", StringComparison.InvariantCultureIgnoreCase))
        {
            sb.AppendLine("                    SerializationUtils.WriteString(item, bufferWriter);");
        }
        else if (arrayItemType.Name.Contains("Memory"))
        {
            sb.AppendLine("                    SerializationUtils.WriteBytes(item, bufferWriter);");
        }
        else 
        {
            sb.AppendLine("                    SerializationUtils.Write(item, bufferWriter);");
        }
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine("            else");
        sb.AppendLine("            {");
        sb.AppendLine("                SerializationUtils.WriteInstanceState(false, bufferWriter);");
        sb.AppendLine("            }");
    }
    
    private static void GenerateDeserializationForItems(ITypeSymbol itemType, StringBuilder sb, string propertyName, bool isList = false)
    {
        sb.AppendLine(isList ? $"            List<{itemType}> items = default;" : $"            {itemType}[] items = default;");

        sb.AppendLine("            if (SerializationUtils.ReadInstanceState(span[offset..], ref offset))");
        sb.AppendLine("            {");
        sb.AppendLine("                var count = SerializationUtils.ReadElementsCount(span[offset..], ref offset);");
        sb.AppendLine(isList
            ? $"                items = new List<{itemType}>(count);"
            : $"                items = new {itemType}[count];");
        sb.AppendLine("                for(var i = 0; i < count; i++)");
        sb.AppendLine("                {");
        sb.AppendLine($"                    {itemType} item = default;");
        sb.AppendLine($"                    item = item.Deserialize(span[offset..], ref offset);");
        sb.AppendLine($"                    items[i] = item;");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine($"            result.{propertyName} = items;");
    }

    private static bool CheckInterfaces(
        SyntaxNode syntaxNode,
        CancellationToken cancellationToken) =>
        syntaxNode.IsKind(SyntaxKind.GenericName) 
        && syntaxNode is GenericNameSyntax v
        && v.Identifier.Text.Contains("UseSignalService");


    private static TypeSyntax? GetTypeOrNull(
        GeneratorSyntaxContext context,
        CancellationToken cancellationToken)
    {
        if (context.Node is GenericNameSyntax i && i.TypeArgumentList.Arguments.Any())
        {
            var node = i.TypeArgumentList.Arguments[0];
            return node;
            //return i;
        }

        return null;
    }
}

internal static class WellKnownTypes
{
    private static readonly IReadOnlyList<string> Types = new[]
    {
        "int",
        "float",
        "byte",
        "long",
        "string",
        "CancellationToken",
        "Memory<byte>",
        "Memory",
    };

    internal static bool Contains(ITypeSymbol symbol) 
        => !NotContains(symbol);
    internal static bool NotContains(ITypeSymbol symbol) 
        => !Types.Contains(symbol.Name) && !Types.Contains($"{symbol}");
    internal static bool NotContains(string symbol) 
        => !Types.Contains(symbol) && !Types.Contains($"{symbol}");
    
    internal static bool IsCancellationToken(ITypeSymbol symbol) 
        => symbol.Name == "CancellationToken" || $"{symbol}" == "CancellationToken";
}