using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace TrueMoon.Thorium.Generator;

[Generator(LanguageNames.CSharp)]
public class SignalsMappingGenerator : IIncrementalGenerator
{
    private const string NamespacePart = "TrueMoon.Generated";
    private const string AttributeName = "SignalAttribute";
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        //context.RegisterPostInitializationOutput(context => context.AddSource($"{AttributeName}.g.cs", "namespace " + NamespacePart + "; [AttributeUsage(AttributeTargets.Class)]public class " + AttributeName + " : Attribute { public " + AttributeName + "() {} }"));

        var data = context.SyntaxProvider
            .CreateSyntaxProvider(CheckClass, GetTypeOrNull2)
            .Where(type => type is not null)
            .Collect();

        var r = context.CompilationProvider.Combine(data);

        context.RegisterSourceOutput(r, static (sourceProductionContext, d) => Generate1(d.Left, d.Right, sourceProductionContext));
    }

    private static void Generate((Compilation Left, ImmutableArray<ITypeSymbol?> Right) d,
        SourceProductionContext sourceProductionContext)
    {
        var compilation = d.Left;
        var values = d.Right;
        var n = d.Left.AssemblyName.Replace(".", string.Empty).Trim();
        var a = d.Left.Assembly.Name;

        var sb = new StringBuilder();
        sb.AppendLine("// auto-generated by TrueMoon.Thorium.Generator");
        sb.AppendLine("using TrueMoon.Thorium;");
        sb.AppendLine();
        sb.AppendLine("namespace TrueMoon.Generated;");
        sb.AppendLine();
        sb.AppendLine($"public sealed class {n}SignalMapping : SignalMappingBase");
        sb.AppendLine("{");
        sb.AppendLine($"    public {n}SignalMapping() : base(\"{a}\")");
        sb.AppendLine("    {");

        foreach (var value in values)
        {
            var attributeData = value?.GetAttributes().FirstOrDefault(t => t.AttributeClass is { Name: AttributeName });

            if (attributeData != null)
            {
                //var args = attr.ConstructorArguments;
                // var code = args.Length > 0 && args[0].Kind != TypedConstantKind.Error
                //     ? (string)args[0].Value
                //     : default;

                //var args = attributeData.NamedArguments;

                sb.AppendLine($"// {attributeData}");
                sb.AppendLine($"// {attributeData.AttributeClass}");
                sb.AppendLine($"// {attributeData.AttributeClass?.Name}");
                sb.AppendLine($"// {attributeData.NamedArguments.Length}");
                sb.AppendLine($"// {attributeData.ConstructorArguments.Length}");
                sb.AppendLine($"// {attributeData.AttributeConstructor?.Name}");
                sb.AppendLine($"// {attributeData.AttributeConstructor?.Parameters.Length}");
                sb.AppendLine($"// {attributeData.AttributeConstructor?.TypeArguments.Length}");
                sb.AppendLine($"// {attributeData.AttributeConstructor?.TypeParameters.Length}");

                string code = attributeData.NamedArguments.IsEmpty.ToString();
                // foreach (KeyValuePair<string, TypedConstant> namedArgument in attributeData.NamedArguments)
                // {
                //     if (namedArgument.Value.Kind == TypedConstantKind.Error)
                //     {
                //         continue;
                //     }
                //
                //     var v = (string)namedArgument.Value.Value;
                //     if (v is { } mn)
                //     {
                //         code = mn;
                //         break;
                //     }
                // }


                var name = value?.Name;
                var fullname = value?.ToDisplayString();

                var interface1 = value?.Interfaces.FirstOrDefault(t => t.Name.Contains("IWithResponse"));

                if (interface1 == null)
                {
                    sb.AppendLine($"        // code:  {code}");
                    sb.AppendLine(
                        $"        AddMapping<{fullname}>(\"{name}\", \"{fullname}\", Guid.Parse(\"{Guid.NewGuid()}\"));");
                }
                else
                {
                    //var intName = interface1?.ToDisplayString();
                    var interfaceArgument = interface1.TypeArguments.FirstOrDefault();

                    var interfaceArgumentName = interfaceArgument?.ToDisplayString();

                    // sb.AppendLine($"        // {intName}");
                    // sb.AppendLine($"        // {interfaceParameterName}");
                    sb.AppendLine($"        // code:  {code}");
                    sb.AppendLine(
                        $"        AddMapping<{fullname},{interfaceArgumentName}>(\"{name}\", \"{fullname}\", Guid.Parse(\"{Guid.NewGuid()}\"));");
                }
            }
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");
        sourceProductionContext.AddSource($"{n}SignalMapping.g.cs", sb.ToString());
    }
    
    private static void Generate1(Compilation compilation, ImmutableArray<ClassDeclarationSyntax?> classes, SourceProductionContext sourceProductionContext)
    {
        if (classes.IsDefaultOrEmpty)
        {
            // nothing to do yet
            return;
        }
        
        var values = classes.Distinct();
        
        // Get a reference to the [EnumExtensions] symbol
        INamedTypeSymbol? attribute = compilation.GetTypeByMetadataName("TrueMoon.Thorium.SignalAttribute");
    
        if (attribute == null)
        {
            // If this is null, the compilation couldn't find the marker attribute type
            // which suggests there's something very wrong! Bail out..
            return;
        }

        var list = new List<(INamedTypeSymbol, string)>();
        foreach (var classDeclarationSyntax in values)
        {
            // Get the semantic model of the enum symbol
            SemanticModel semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);
            var classSymbol1 = semanticModel.GetDeclaredSymbol(classDeclarationSyntax);

            if (classSymbol1 is not INamedTypeSymbol classSymbol)
            {
                // something went wrong, bail out
                continue;
            }
            
            // Set the default extension name
            string codeValue = "";

            // Loop through all of the attributes on the enum
            foreach (AttributeData attributeData in classSymbol.GetAttributes())
            {
                if (!attribute.Equals(attributeData.AttributeClass, SymbolEqualityComparer.Default))
                {
                    // This isn't the [Signal] attribute
                    continue;
                }


                // This is the attribute, check all of the named arguments
                foreach (KeyValuePair<string, TypedConstant> namedArgument in attributeData.NamedArguments)
                {
                    // Is this the ExtensionClassName argument?
                    if (namedArgument.Key == "Code"
                        && namedArgument.Value.Value?.ToString() is { } cValue)
                    {
                        codeValue = cValue;
                    }
                }

                break;
            }
            
            list.Add((classSymbol, codeValue));
        }
        
        var n = compilation.AssemblyName.Replace(".", string.Empty).Trim();
        var a = compilation.Assembly.Name;

        var sb = new StringBuilder();
        sb.AppendLine("// auto-generated by TrueMoon.Thorium.Generator");
        sb.AppendLine("using TrueMoon.Thorium;");
        sb.AppendLine();
        sb.AppendLine("namespace TrueMoon.Generated;");
        sb.AppendLine();
        sb.AppendLine($"public sealed class {n}SignalMapping : SignalMappingBase");
        sb.AppendLine("{");
        sb.AppendLine($"    public {n}SignalMapping() : base(\"{a}\")");
        sb.AppendLine("    {");

        foreach (var (type, code) in list)
        {
            var name = type?.Name;
            var fullname = type?.ToDisplayString();

            var interface1 = type?.Interfaces.FirstOrDefault(t => t.Name.Contains("IWithResponse"));

            string guid;
            if (string.IsNullOrWhiteSpace(code))
            {
                guid = Guid.NewGuid().ToString();
            }
            else
            {
                guid = code;
                sb.AppendLine($"        // static signal");
            };  
            
            if (interface1 == null)
            {
                sb.AppendLine(
                    $"        AddMapping<{fullname}>(\"{name}\", \"{fullname}\", Guid.Parse(\"{guid}\"));");
            }
            else
            {
                var interfaceArgument = interface1.TypeArguments.FirstOrDefault();

                var interfaceArgumentName = interfaceArgument?.ToDisplayString();
                
                sb.AppendLine(
                    $"        AddMapping<{fullname},{interfaceArgumentName}>(\"{name}\", \"{fullname}\", Guid.Parse(\"{guid}\"));");
            }
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");
        sourceProductionContext.AddSource($"{n}SignalMapping.g.cs", sb.ToString());
    }

    private static bool CheckClass(
        SyntaxNode syntaxNode,
        CancellationToken cancellationToken) =>
        syntaxNode is ClassDeclarationSyntax { AttributeLists.Count: > 0 };

    private static ITypeSymbol? GetTypeOrNull(
        GeneratorSyntaxContext context,
        CancellationToken cancellationToken)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        
        return context.SemanticModel.GetDeclaredSymbol(classDeclaration) is ITypeSymbol type 
               && type.GetAttributes().Any(t=>t.AttributeClass is { Name: AttributeName }) 
            ? type 
            : null;
    }    
    
    private static ClassDeclarationSyntax? GetTypeOrNull2(
        GeneratorSyntaxContext context,
        CancellationToken cancellationToken)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;

        // loop through all the attributes on the method
        foreach (AttributeListSyntax attributeListSyntax in classDeclaration.AttributeLists)
        {
            foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                {
                    // weird, we couldn't get the symbol, ignore it
                    continue;
                }

                INamedTypeSymbol attributeContainingTypeSymbol = attributeSymbol.ContainingType;
                string fullName = attributeContainingTypeSymbol.ToDisplayString();
                string name = attributeContainingTypeSymbol.Name;

                // Is the attribute the [SignalAttribute] attribute?
                if (name == "SignalAttribute")
                {
                    return classDeclaration;
                }
            }
        }

        // we didn't find the attribute we were looking for
        return null;
    }
}