using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace TrueMoon.Cobalt.Generator;

[Generator(LanguageNames.CSharp)]
public class CobaltGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var data = context.SyntaxProvider
            .CreateSyntaxProvider(CheckInterfaces, GetTypeOrNull)
            .Where(item => item.Item2 is not null)
            .Collect();

        var r = context.CompilationProvider.Combine(data);

        context.RegisterSourceOutput(r,
            static (sourceProductionContext, d) => Generate1(d.Left, d.Right, sourceProductionContext));
    }

    private static void Generate1(Compilation compilation, ImmutableArray<(int,TypeSyntax?,TypeSyntax?)> interfaces,
        SourceProductionContext sourceProductionContext)
    {
        if (interfaces.IsDefaultOrEmpty)
        {
            return;
        }

        try
        {
            var assembly = compilation.Assembly.Name;
            
        
            var values = interfaces.Distinct();
        

            var list = new List<string>();
            foreach (var syntax in values)
            {
                SemanticModel semanticModel = compilation.GetSemanticModel(syntax.Item2.SyntaxTree);
                var typeInfo = semanticModel.GetTypeInfo(syntax.Item2);
                var typeSymbol = typeInfo.Type;
                
                SemanticModel semanticModel2 = compilation.GetSemanticModel(syntax.Item3.SyntaxTree);
                var typeInfo2 = semanticModel2.GetTypeInfo(syntax.Item3);
                var typeSymbol2 = typeInfo2.Type;

                if (typeSymbol is not INamedTypeSymbol interfaceSymbol)
                {
                    continue;
                }
        
                // if (list.Any(t=> SymbolEqualityComparer.Default.Equals(t.interfaceSymbol, interfaceSymbol)))
                // {
                //     continue;
                // }

                var generated = GenerateTypeResolver(syntax.Item1, interfaceSymbol, typeSymbol2 as INamedTypeSymbol);
                
                sourceProductionContext.AddSource($"{generated.name}.g.cs", generated.code);
                
                list.Add(generated.name);
            }
        
            var sb = new StringBuilder();
            sb.AppendLine("// auto-generated by TrueMoon.Cobalt.Generator");
            sb.AppendLine("using TrueMoon.Cobalt;");
            sb.AppendLine("using System.Runtime.CompilerServices;");
            sb.AppendLine();
            sb.AppendLine($"namespace TrueMoon.Cobalt.Generated;");
            sb.AppendLine();
        
            sb.AppendLine("public static class CobaltResolversRegistration");
            sb.AppendLine("{");
            sb.AppendLine("    [ModuleInitializer]");
            sb.AppendLine("    public static void Init()");
            sb.AppendLine("    {");
            foreach (var service in list)
            {
                sb.AppendLine($"        ServiceResolvers.Shared.Add(() => new {service}());");
            }
            sb.AppendLine("    }");
            sb.AppendLine("}");

            var source = sb.ToString();
            sourceProductionContext.AddSource("CobaltResolversRegistration.g.cs", source);
        }
        catch (Exception e)
        {
            throw new InvalidOperationException($"Exception - {e.GetType()}: {e.Message}, StackTrace: {e.StackTrace}", e);
        }
    }

    private static (string name, string code) GenerateTypeResolver(int lifetime, INamedTypeSymbol service, INamedTypeSymbol? implementation = default)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// auto-generated by TrueMoon.Cobalt.Generator");
        sb.AppendLine("using TrueMoon.Cobalt;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine();
        sb.AppendLine("namespace TrueMoon.Cobalt.Generated;");
        sb.AppendLine();
        
        if (implementation != null)
        {
            sb.AppendLine($"public class {implementation.Name}Resolver : IResolver<global::{service}, global::{implementation}>");
        }
        else
        {
            sb.AppendLine($"public class {service.Name}Resolver : IResolver<global::{service}>");
        }
        
        var resolvingType = implementation ?? service;
        
        var higherConstructor = resolvingType.InstanceConstructors
            .OrderByDescending(t => t.Parameters.Length)
            .FirstOrDefault();
        
        sb.AppendLine("{");
        
        if (lifetime == 0)
        {
            sb.AppendLine($"    private global::{service.Name} _instance;");
            sb.AppendLine();
        }
        
        switch (lifetime)
        {
            case 0:
                sb.AppendLine("    public ResolvingServiceLifetime ServiceLifetime => ResolvingServiceLifetime.Singleton;");
                break;
            case 1:
                sb.AppendLine("    public ResolvingServiceLifetime ServiceLifetime => ResolvingServiceLifetime.Transient;");
                break;
        }

        sb.AppendLine();
        
        sb.AppendLine($"    public global::{service.Name} Resolve(IResolvingContext context)");
        sb.AppendLine("    {");
        
        if (lifetime == 0)
        {
            sb.AppendLine($"        if(_instance != null) return _instance;");
            sb.AppendLine();
        }
        
        var i = 0;
        var parametersString = string.Empty;
        foreach (var symbol in higherConstructor.Parameters)
        {
            var serviceName = $"service{i}"; 
            sb.AppendLine($"        var {serviceName} = context.Resolve<global::{symbol.Type}>();");
            parametersString += serviceName + ",";
            i++;
        }

        if (lifetime == 0)
        {
            sb.AppendLine($"        _instance = new global::{resolvingType}({parametersString.TrimEnd(',')});");
            sb.AppendLine("        return _instance;");
        }
        else
        {
            sb.AppendLine($"        return new global::{resolvingType}({parametersString.TrimEnd(',')});");
        }
        
        sb.AppendLine("    }");

        var isDisposable = resolvingType.AllInterfaces.Any(t=>t.Name == "IDisposable");
        
        sb.AppendLine();
        sb.AppendLine("    public bool IsServiceDisposable { get; } = " + (isDisposable ? "true" : "false") + ";");
        sb.AppendLine("}");

        var source = sb.ToString();

        return ($"{implementation.Name}Resolver", source);
    }
    
    private static bool CheckInterfaces(
        SyntaxNode syntaxNode,
        CancellationToken cancellationToken) =>
        syntaxNode.IsKind(SyntaxKind.GenericName)
        && syntaxNode is GenericNameSyntax { Identifier.Text: "AddSingleton" or "AddTransient" or "Add" };


    private static (int,TypeSyntax?,TypeSyntax?) GetTypeOrNull(
        GeneratorSyntaxContext context,
        CancellationToken cancellationToken)
    {
        if (context.Node is GenericNameSyntax i && i.TypeArgumentList.Arguments.Any())
        {
            var regType = i.Identifier.Text switch
            {
                "AddSingleton" => 0,
                "AddTransient" => 1,
                "Add" => 0,
                _ => -1
            };

            if (i.TypeArgumentList.Arguments.Count == 2)
            {
                var node = i.TypeArgumentList.Arguments[0];
                var node2 = i.TypeArgumentList.Arguments[1];
                return (regType, node, node2);
            }
            if (i.TypeArgumentList.Arguments.Count == 1)
            {
                var node = i.TypeArgumentList.Arguments[0];
                return (regType, node, null);
            }
        }

        return (-1, null, null);
    }
}